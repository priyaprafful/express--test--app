'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const prismicH = require('@prismicio/helpers');

function _interopNamespace(e) {
	if (e && e.__esModule) return e;
	const n = Object.create(null);
	if (e) {
		for (const k in e) {
			if (k !== 'default') {
				const d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		}
	}
	n["default"] = e;
	return Object.freeze(n);
}

const prismicH__namespace = /*#__PURE__*/_interopNamespace(prismicH);

const getEndpoint = (repositoryName) => `https://${repositoryName}.cdn.prismic.io/api/v2`;

const castArray = (a) => Array.isArray(a) ? a : [a];

const RENAMED_PARAMS = {
  accessToken: "access_token"
};
const castOrderingToString = (ordering) => typeof ordering === "string" ? ordering : [
  ordering.field,
  ordering.direction === "desc" ? ordering.direction : void 0
].filter(Boolean).join(" ");
const buildQueryURL = (endpoint, args) => {
  var _a;
  const { predicates, ...params } = args;
  const url = new URL(`documents/search`, `${endpoint}/`);
  if (predicates) {
    for (const predicate of castArray(predicates)) {
      url.searchParams.append("q", `[${predicate}]`);
    }
  }
  for (const k in params) {
    const name = (_a = RENAMED_PARAMS[k]) != null ? _a : k;
    let value = params[k];
    if (name === "orderings") {
      const scopedValue = params[name];
      if (scopedValue != null) {
        const v = castArray(scopedValue).map((ordering) => castOrderingToString(ordering)).join(",");
        value = `[${v}]`;
      }
    } else if (name === "routes") {
      if (typeof params[name] === "object") {
        value = JSON.stringify(castArray(params[name]));
      }
    }
    if (value != null) {
      url.searchParams.set(name, castArray(value).join(","));
    }
  }
  return url.toString();
};

const appendPredicates = (objWithPredicates = {}, predicates) => {
  return {
    ...objWithPredicates,
    predicates: [
      ...objWithPredicates.predicates || [],
      ...castArray(predicates)
    ]
  };
};

const castThunk = (a) => typeof a === "function" ? a : () => a;

class PrismicError extends Error {
  constructor(message = "An invalid API response was returned", url, response) {
    super(message);
    this.url = url;
    this.response = response;
  }
}

const findRef = (refs, predicate) => {
  const ref = refs.find((ref2) => predicate(ref2));
  if (!ref) {
    throw new PrismicError("Ref could not be found.", void 0, void 0);
  }
  return ref;
};

const findMasterRef = (refs) => {
  return findRef(refs, (ref) => ref.isMasterRef);
};

const findRefByID = (refs, id) => {
  return findRef(refs, (ref) => ref.id === id);
};

const findRefByLabel = (refs, label) => {
  return findRef(refs, (ref) => ref.label === label);
};

const readValue = (value) => {
  return value.replace(/%3B/g, ";");
};
const parse = (cookieString) => {
  const result = {};
  const cookies = cookieString.split("; ");
  for (const cookie of cookies) {
    const parts = cookie.split("=");
    const value = parts.slice(1).join("=");
    const name = readValue(parts[0]).replace(/%3D/g, "=");
    result[name] = readValue(value);
  }
  return result;
};
const getAll = (cookieStore) => parse(cookieStore);
const getCookie = (name, cookieStore) => getAll(cookieStore)[name];

class ForbiddenError extends PrismicError {
}

class ParsingError extends PrismicError {
}

const formatValue = (value) => {
  if (Array.isArray(value)) {
    return `[${value.map(formatValue).join(", ")}]`;
  }
  if (typeof value === "string") {
    return `"${value}"`;
  }
  if (value instanceof Date) {
    return `${value.getTime()}`;
  }
  return `${value}`;
};
const pathWithArgsPredicate = (name) => {
  const fn = (path, ...args) => {
    const formattedArgs = args.map(formatValue).join(", ");
    const joiner = path && args.length ? ", " : "";
    return `[${name}(${path}${joiner}${formattedArgs})]`;
  };
  return fn;
};
const pathPredicate = (name) => {
  const predicateFn = pathWithArgsPredicate(name);
  const fn = (path) => {
    return predicateFn(path);
  };
  return fn;
};
const argsPredicate = (name) => {
  const predicateFn = pathWithArgsPredicate(name);
  const fn = (...args) => {
    return predicateFn("", ...args);
  };
  return fn;
};
const predicate = {
  at: pathWithArgsPredicate("at"),
  not: pathWithArgsPredicate("not"),
  any: pathWithArgsPredicate("any"),
  in: pathWithArgsPredicate("in"),
  fulltext: pathWithArgsPredicate("fulltext"),
  has: pathPredicate("has"),
  missing: pathPredicate("missing"),
  similar: argsPredicate("similar"),
  geopointNear: pathWithArgsPredicate("geopoint.near"),
  numberLessThan: pathWithArgsPredicate("number.lt"),
  numberGreaterThan: pathWithArgsPredicate("number.gt"),
  numberInRange: pathWithArgsPredicate("number.inRange"),
  dateAfter: pathWithArgsPredicate("date.after"),
  dateBefore: pathWithArgsPredicate("date.before"),
  dateBetween: pathWithArgsPredicate("date.between"),
  dateDayOfMonth: pathWithArgsPredicate("date.day-of-month"),
  dateDayOfMonthAfter: pathWithArgsPredicate("date.day-of-month-after"),
  dateDayOfMonthBefore: pathWithArgsPredicate("date.day-of-month-before"),
  dateDayOfWeek: pathWithArgsPredicate("date.day-of-week"),
  dateDayOfWeekAfter: pathWithArgsPredicate("date.day-of-week-after"),
  dateDayOfWeekBefore: pathWithArgsPredicate("date.day-of-week-before"),
  dateMonth: pathWithArgsPredicate("date.month"),
  dateMonthAfter: pathWithArgsPredicate("date.month-after"),
  dateMonthBefore: pathWithArgsPredicate("date.month-before"),
  dateYear: pathWithArgsPredicate("date.year"),
  dateHour: pathWithArgsPredicate("date.hour"),
  dateHourAfter: pathWithArgsPredicate("date.hour-after"),
  dateHourBefore: pathWithArgsPredicate("date.hour-before")
};

const preview = "io.prismic.preview";

const cookie = /*#__PURE__*/Object.freeze({
	__proto__: null,
	preview: preview
});

const MAX_PAGE_SIZE = 100;
const REPOSITORY_CACHE_TTL = 5e3;
const GET_ALL_QUERY_DELAY = 500;
var RefStateMode;
(function(RefStateMode2) {
  RefStateMode2["Master"] = "Master";
  RefStateMode2["ReleaseID"] = "ReleaseID";
  RefStateMode2["ReleaseLabel"] = "ReleaseLabel";
  RefStateMode2["Manual"] = "Manual";
})(RefStateMode || (RefStateMode = {}));
const typePredicate = (documentType) => predicate.at("document.type", documentType);
const everyTagPredicate = (tags) => predicate.at("document.tags", tags);
const someTagsPredicate = (tags) => predicate.any("document.tags", tags);
const createClient = (...args) => new Client(...args);
class Client {
  constructor(endpoint, options = {}) {
    this.refState = {
      mode: RefStateMode.Master,
      autoPreviewsEnabled: true
    };
    this.cachedRepositoryExpiration = 0;
    this.endpoint = endpoint;
    this.accessToken = options.accessToken;
    this.routes = options.routes;
    this.defaultParams = options.defaultParams;
    if (options.ref) {
      this.queryContentFromRef(options.ref);
    }
    if (typeof options.fetch === "function") {
      this.fetchFn = options.fetch;
    } else if (typeof globalThis.fetch === "function") {
      this.fetchFn = globalThis.fetch;
    } else {
      throw new PrismicError("A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.", void 0, void 0);
    }
    if (this.fetchFn === globalThis.fetch) {
      this.fetchFn = this.fetchFn.bind(globalThis);
    }
  }
  enableAutoPreviews() {
    this.refState.autoPreviewsEnabled = true;
  }
  enableAutoPreviewsFromReq(req) {
    this.refState.httpRequest = req;
    this.refState.autoPreviewsEnabled = true;
  }
  disableAutoPreviews() {
    this.refState.autoPreviewsEnabled = false;
  }
  async query(predicates, params) {
    const url = await this.buildQueryURL({ ...params, predicates });
    return await this.fetch(url, params);
  }
  async get(params) {
    const url = await this.buildQueryURL(params);
    return await this.fetch(url, params);
  }
  async getFirst(params) {
    const url = await this.buildQueryURL(params);
    const result = await this.fetch(url, params);
    const firstResult = result.results[0];
    if (firstResult) {
      return firstResult;
    }
    throw new PrismicError("No documents were returned", url, void 0);
  }
  async dangerouslyGetAll(params = {}) {
    const { limit = Infinity, ...actualParams } = params;
    const resolvedParams = {
      ...actualParams,
      pageSize: actualParams.pageSize || MAX_PAGE_SIZE
    };
    const documents = [];
    let latestResult;
    while ((!latestResult || latestResult.next_page) && documents.length < limit) {
      const page = latestResult ? latestResult.page + 1 : void 0;
      latestResult = await this.get({ ...resolvedParams, page });
      documents.push(...latestResult.results);
      if (latestResult.next_page) {
        await new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY));
      }
    }
    return documents.slice(0, limit);
  }
  async getByID(id, params) {
    return await this.getFirst(appendPredicates(params, predicate.at("document.id", id)));
  }
  async getByIDs(ids, params) {
    return await this.get(appendPredicates(params, predicate.in("document.id", ids)));
  }
  async getAllByIDs(ids, params) {
    return await this.dangerouslyGetAll(appendPredicates(params, predicate.in("document.id", ids)));
  }
  async getByUID(documentType, uid, params) {
    return await this.getFirst(appendPredicates(params, [
      typePredicate(documentType),
      predicate.at(`my.${documentType}.uid`, uid)
    ]));
  }
  async getByUIDs(documentType, uids, params) {
    return await this.get(appendPredicates(params, [
      typePredicate(documentType),
      predicate.in(`my.${documentType}.uid`, uids)
    ]));
  }
  async getAllByUIDs(documentType, uids, params) {
    return await this.dangerouslyGetAll(appendPredicates(params, [
      typePredicate(documentType),
      predicate.in(`my.${documentType}.uid`, uids)
    ]));
  }
  async getSingle(documentType, params) {
    return await this.getFirst(appendPredicates(params, typePredicate(documentType)));
  }
  async getByType(documentType, params) {
    return await this.get(appendPredicates(params, typePredicate(documentType)));
  }
  async getAllByType(documentType, params) {
    return await this.dangerouslyGetAll(appendPredicates(params, typePredicate(documentType)));
  }
  async getByTag(tag, params) {
    return await this.get(appendPredicates(params, everyTagPredicate(tag)));
  }
  async getAllByTag(tag, params) {
    return await this.dangerouslyGetAll(appendPredicates(params, everyTagPredicate(tag)));
  }
  async getByEveryTag(tags, params) {
    return await this.get(appendPredicates(params, everyTagPredicate(tags)));
  }
  async getAllByEveryTag(tags, params) {
    return await this.dangerouslyGetAll(appendPredicates(params, everyTagPredicate(tags)));
  }
  async getBySomeTags(tags, params) {
    return await this.get(appendPredicates(params, someTagsPredicate(tags)));
  }
  async getAllBySomeTags(tags, params) {
    return await this.dangerouslyGetAll(appendPredicates(params, someTagsPredicate(tags)));
  }
  async getRepository() {
    const url = new URL(this.endpoint);
    if (this.accessToken) {
      url.searchParams.set("access_token", this.accessToken);
    }
    return await this.fetch(url.toString());
  }
  async getRefs() {
    const repository = await this.getRepository();
    return repository.refs;
  }
  async getRefByID(id) {
    const refs = await this.getRefs();
    return findRefByID(refs, id);
  }
  async getRefByLabel(label) {
    const refs = await this.getRefs();
    return findRefByLabel(refs, label);
  }
  async getMasterRef() {
    const refs = await this.getRefs();
    return findMasterRef(refs);
  }
  async getReleases() {
    const refs = await this.getRefs();
    return refs.filter((ref) => !ref.isMasterRef);
  }
  async getReleaseByID(id) {
    const releases = await this.getReleases();
    return findRefByID(releases, id);
  }
  async getReleaseByLabel(label) {
    const releases = await this.getReleases();
    return findRefByLabel(releases, label);
  }
  async getTags() {
    try {
      const tagsForm = await this.getCachedRepositoryForm("tags");
      return await this.fetch(tagsForm.action);
    } catch (e) {
      const repository = await this.getRepository();
      return repository.tags;
    }
  }
  async buildQueryURL(params = {}) {
    const ref = params.ref || await this.getResolvedRefString();
    const integrationFieldsRef = params.integrationFieldsRef || (await this.getCachedRepository()).integrationFieldsRef || void 0;
    return buildQueryURL(this.endpoint, {
      ...this.defaultParams,
      ...params,
      ref,
      integrationFieldsRef,
      routes: params.routes || this.routes,
      accessToken: params.accessToken || this.accessToken
    });
  }
  async resolvePreviewURL(args) {
    var _a;
    let documentID = args.documentID;
    let previewToken = args.previewToken;
    if (typeof globalThis.location !== "undefined") {
      const searchParams = new URLSearchParams(globalThis.location.search);
      documentID = documentID || searchParams.get("documentId") || void 0;
      previewToken = previewToken || searchParams.get("token") || void 0;
    } else if ((_a = this.refState.httpRequest) == null ? void 0 : _a.query) {
      documentID = documentID || this.refState.httpRequest.query.documentId;
      previewToken = previewToken || this.refState.httpRequest.query.token;
    }
    if (documentID != null) {
      const document = await this.getByID(documentID, {
        ref: previewToken
      });
      return prismicH__namespace.asLink(document, args.linkResolver);
    } else {
      return args.defaultURL;
    }
  }
  queryLatestContent() {
    this.refState.mode = RefStateMode.Master;
  }
  queryContentFromReleaseByID(releaseID) {
    this.refState = {
      ...this.refState,
      mode: RefStateMode.ReleaseID,
      releaseID
    };
  }
  queryContentFromReleaseByLabel(releaseLabel) {
    this.refState = {
      ...this.refState,
      mode: RefStateMode.ReleaseLabel,
      releaseLabel
    };
  }
  queryContentFromRef(ref) {
    this.refState = {
      ...this.refState,
      mode: RefStateMode.Manual,
      ref
    };
  }
  async getCachedRepository() {
    if (!this.cachedRepository || Date.now() >= this.cachedRepositoryExpiration) {
      this.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL;
      this.cachedRepository = await this.getRepository();
    }
    return this.cachedRepository;
  }
  async getCachedRepositoryForm(name) {
    const cachedRepository = await this.getCachedRepository();
    const form = cachedRepository.forms[name];
    if (!form) {
      throw new PrismicError(`Form with name "${name}" could not be found`, void 0, void 0);
    }
    return form;
  }
  async getResolvedRefString() {
    var _a, _b, _c;
    if (this.refState.autoPreviewsEnabled) {
      let previewRef = void 0;
      if ((_a = globalThis.document) == null ? void 0 : _a.cookie) {
        previewRef = getCookie(preview, globalThis.document.cookie);
      } else if ((_c = (_b = this.refState.httpRequest) == null ? void 0 : _b.headers) == null ? void 0 : _c.cookie) {
        previewRef = getCookie(preview, this.refState.httpRequest.headers.cookie);
      }
      if (previewRef) {
        return previewRef;
      }
    }
    const cachedRepository = await this.getCachedRepository();
    const refModeType = this.refState.mode;
    if (refModeType === RefStateMode.ReleaseID) {
      return findRefByID(cachedRepository.refs, this.refState.releaseID).ref;
    } else if (refModeType === RefStateMode.ReleaseLabel) {
      return findRefByLabel(cachedRepository.refs, this.refState.releaseLabel).ref;
    } else if (refModeType === RefStateMode.Manual) {
      const res = await castThunk(this.refState.ref)();
      if (typeof res === "string") {
        return res;
      }
    }
    return findMasterRef(cachedRepository.refs).ref;
  }
  async fetch(url, _params) {
    const res = await this.fetchFn(url);
    let json;
    try {
      json = await res.json();
    } catch (e) {
      throw new PrismicError(void 0, url, void 0);
    }
    switch (res.status) {
      case 200: {
        return json;
      }
      case 400: {
        throw new ParsingError(json.message, url, json);
      }
      case 401:
      case 403: {
        throw new ForbiddenError("error" in json ? json.error : json.message, url, json);
      }
    }
    throw new PrismicError(void 0, url, json);
  }
}

const predicates = predicate;
const Predicates = predicate;

exports.Client = Client;
exports.ForbiddenError = ForbiddenError;
exports.ParsingError = ParsingError;
exports.Predicates = Predicates;
exports.PrismicError = PrismicError;
exports.buildQueryURL = buildQueryURL;
exports.cookie = cookie;
exports.createClient = createClient;
exports.getEndpoint = getEndpoint;
exports.predicate = predicate;
exports.predicates = predicates;
//# sourceMappingURL=index.cjs.map
